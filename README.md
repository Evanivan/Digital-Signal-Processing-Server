# ***Сервер обработки цифрового сигнала/ Digital Signal Processing Server*** 


**Содержание:** Серверное приложение на C++, обрабатывающее 3D-данные сигнала с фильтрацией, усреднением и расчетом статистики.

## Используемые инструменты и фреймворки

1.  **CMake**
    *   **Версия:** Минимальная требуемая версия — 3.15.

2.  **Google Test**
    *   **Назначение:** Написание и запуск автоматизированных тестов.
    *   **Версия:** 1.14.0.
    *   **Описание:** Google Test используется для создания и выполнения юнит-тестов.

## Библиотеки

1.  **Boost**
    *   **Версия:** 1.67.
    *   **Описание:** Используется для поддержки системных компонентов и сетевых операций.

2.  **easylogging++**
    *   **Назначение:** Логирование событий.
    *   **Версия:** Используется header only библиотека Easylogging++ v9.97.1.
    https://github.com/abumq/easyloggingpp/blob/master/LICENSE
    *   **Описание:** easylogging++ используется для логирования событий в консоль и файлы.

3.  **nlohmann/json**
    *   **Назначение:** Работа с JSON-данными.
    *   **Версия:** Используется header only библиотека version 3.11.2.
    https://github.com/nlohmann/json
    *   **Описание:** Эта библиотека позволяет легко сериализовать и десериализовать данные в формате JSON.

## Другие Зависимости

1.  **C++ Стандарт**
    *   **Версия:** C++17.
    *   **Описание:** Используется для обеспечения совместимости с современными стандартами языка C++.

Эти инструменты и библиотеки позволяют создать полноценный сервер для обработки цифровых сигналов с поддержкой сетевого взаимодействия, логирования и тестирования.

## Правила сборки проекта

### Обычная сборка (Release)
```bash
./build.sh
```

### Сборка с тестами
```bash
./build.sh --tests
```

### Сборка Debug с тестами
```bash
./build.sh --debug --tests
```

### Только сборка Debug
```bash
./build.sh --debug
```

Примечания:

1. Все команды выполняются из корневой директории проекта
2. Для просмотра подробного вывода используйте флаг -v в конце команд
3. После успешной сборки бинарные файлы будут находиться в директории build/

# Разные виды конфигурации и входных данных


## Конфигурации
-------------

### **Конфигурация 1: Базовая**

```json
{
    "port": 8080,
    "log_path": "server.log",
    "median_window_x": 3,
    "median_window_y": 3,
    "gaussian_sigma_x": 1.0,
    "gaussian_sigma_y": 1.0,
    "moving_window": 5
}
```


### **Конфигурация 2: Увеличенные размеры окон фильтров**

```json
{
    "port": 8080,
    "log_path": "server.log",
    "median_window_x": 5,
    "median_window_y": 5,
    "gaussian_sigma_x": 1.5,
    "gaussian_sigma_y": 1.5,
    "moving_window": 10
}
```



## Входные данные
----------------

### **Пример 1: Маленькие размерности**

```
struct SignalData {
    uint32_t x = 2;
    uint32_t y = 2;
    uint32_t z = 1;
    float data[] = {1.0f, 2.0f, 3.0f, 4.0f};
};
```

### **Пример 2: Большие размерности**

```
struct SignalData {
    uint32_t x = 10;
    uint32_t y = 10;
    uint32_t z = 1;
    float data[] = {1.0f, 2.0f, 3.0f, ..., 100.0f}; // 100 элементов
};
```


### **Пример 3: Трехмерные данные**

```
struct SignalData {
    uint32_t x = 5;
    uint32_t y = 5;
    uint32_t z = 2;
    float data[] = {1.0f, 2.0f, ..., 50.0f}; // 50 элементов
};
```


## Выходные данные
-----------------

### **Пример 1: Базовый**

```json
{
    "processed_data": [1.5, 2.5, 3.5, 4.5],
    "stats": {
        "mean": 3.0,
        "stddev": 1.11803
    }
}
```


### **Пример 2: С применением фильтров**

```json
{
    "processed_data": [2.0, 2.5, 3.0, 3.5],
    "stats": {
    "mean": 2.75,
    "stddev": 0.5
    }
}
```


### **Пример 3: С большим объемом данных**

```json
{
    "processed_data": [1.0, 1.5, 2.0, ..., 10.0], // 100 элементов
    "stats": {
    "mean": 5.5,
    "stddev": 2.5
    }
}
```